[{"title":"政治","url":"/2024/06/03/politics/","content":"\n<!-- 双方的缺点的对位是对方的优点\n\n多党制的缺点：\n\n+ 观点极化\n+ 内耗\n+ 注重短期利益以拉取选票\n\n一党制的缺点：\n\n+ 边缘群体的诉求得不到表达\n+ 容易掀桌子 -->","tags":["政治"],"categories":["stuff"]},{"title":"基于hexo和github搭建个人博客","url":"/2024/06/03/build-a-blog/","content":"# 用github搭建一个博客\n## github以 `username.github.io` 为名字创建一个仓库\n+ 名字不能改\n+ 类型必须是 `public`\n\n## 下载 node.js\n[官网](https://nodejs.org/en)下载即可\n\n检查安装成功：\n\n```\nnode -v\nnpm -v\n```\n\n## 安装 hexo\n\n+ 安装 hexo\n\n  ```bash\n  npm install -g hexo-cli\n  ```\n\n+ 初始化一个博客文件夹（在当前目录下）\n\n  ```bash\n  hexo init myblog \n  cd myblog\n  ```\n\n+ 安装 npm\n\n  ```\n  npm install\n  ```\n\n+ 安装 deploy-git\n\n  ```bash\n  npm install hexo-deployer-git --save\n  ```\n\n## 将hexo部署到github\n+ 修改 `_config.yml` 文件：\n  ```\n  deploy:\n  type: git\n  repo: https://github.com/YourgithubName/YourgithubName.github.io.git\n  branch: master\n  ```\n\n## hexo 常用命令\n\n+ `hexo clean`：清除之前生成的东西\n+ `hexo generate|g`：生成静态网页\n+ `hexo deploy|d`：部署文章\n+ `hexo new <文章名>`：新建一篇文章\n+ \n## 常用网站\n+ [hexo官网](https://hexo.io/zh-cn/)","tags":["工具类"]},{"title":"argparse","url":"/2024/06/03/argparse/","content":"argparse 模块用于命令项选项与参数解析。\n\n**示例**\n\n```python\n# test.py\nimport argparse\n\nparser = argparse.ArgumentParser(description='Demo of a argparse')\n\n# 添加参数\nparser.add_argument('--epochs',type=int,default=30,help=\"This is epochs\")\nparser.add_argument('--batch',type=int,default=4,help=\"This is batch\")\n\nargs=parser.parse_args()\n\nprint(args)\n\nepochs=args.epochs\n\nbatch=args.batch\n\nprint(f\"show {epochs} {batch}\")\n```\n\n使用命令：\n```sh\npython test2.py\n```\n\n输出如下：\n```\nNamespace(epochs=30, batch=4)\nshow 30 4\n```\n\n使用命令：\n```sh\npython test2.py --epochs 100 --batch 10\n```\n\n输出如下：\n```\nNamespace(epochs=100, batch=10)\nshow 100 10\n```\n\n使用命令：\n```sh\npython test2.py -h\n```\n\n输出如下：\n```\nusage: test2.py [-h] [--epochs EPOCHS] [--batch BATCH]\n\nDemo of a argparse\n\noptional arguments:\n  -h, --help       show this help message and exit    \n  --epochs EPOCHS  This is epochs\n  --batch BATCH    This is batch\n```\n\n**add_argument 的参数**\n\n+ `type=int`：类型\n\n+ `default=30`：默认值\n\n+ `help=This is epochs`：对参数的介绍信息（通过 `-h` 查看）\n\n+ `metavar='FILE'`：帮助信息中用于表示这个参数的值应该是什么类型的。\n\n+ `action='store_true'`：如果在命令行中出现了 `--if_fog` 这个参数，那么相应的变量（在这里是 `args.if_fog`）将被设置为 `True`。这是一种常见的用法，用于启用或禁用某些功能，而不需要显式地写出 `=True` 或 `=False`。\n\n+ `choices=['cifar10', 'cifar100']`：该参数的可选值\n\n  ","tags":["常用库"],"categories":["python"]},{"title":"partial","url":"/2024/06/03/functools/","content":"\n## partial\n\n`partial`函数用于从一个函数创建一个新的函数，同时预先设定好一些参数。\n\n```python\nfrom functools import partial\n\ndef add(a,b):\n    return a+b\n\nadd1=partial(add,a=1)\nadd1(b=2)\n```\n\n注意这里调用 `add1()` 时必须写 `add1(b=2)` 二不能写 `add1(2)` 了。","tags":["常用库"],"categories":["python"]},{"title":"copy","url":"/2024/06/03/copy/","content":"Python的`copy`库提供了通用的浅拷贝（shallow copy）和深拷贝（deep copy）操作。这个库对于处理复杂的数据结构（如列表、字典、自定义对象等）时，实现对象的复制非常有用，特别是当你需要复制的对象包含了对其他对象的引用时。\n\n### 浅拷贝（Shallow Copy）\n\n浅拷贝创建一个新对象，但它不会递归地复制对象中引用的其他对象，而是复制这些引用本身。这意味着，如果原始对象中的某个成员是对另一个对象的引用，那么在浅拷贝版本中，这个成员仍然指向同一个对象。因此，修改这个被引用的对象将会影响到原始对象和它的浅拷贝版本。\n\n在`copy`库中，可以使用`copy()`函数来执行浅拷贝操作：\n\n```python\nimport copy\nobj_copy = copy.copy(original_obj)\n```\n\n### 深拷贝（Deep Copy）\n\n深拷贝创建一个新对象，然后递归地复制原始对象中引用的所有对象。这意味着，如果原始对象包含了对其他对象的引用，深拷贝不仅会复制原始对象本身，还会复制所有被引用的对象及其链条上的对象。因此，原始对象和它的深拷贝版本在结构上完全独立，修改任何一个对象的成员都不会影响到另一个。\n\n在`copy`库中，可以使用`deepcopy()`函数来执行深拷贝操作：\n\n```python\nimport copy\nobj_deepcopy = copy.deepcopy(original_obj)\n```\n\n### 例子\n\n```python\nimport copy\n\na=[1,2,3]\nb=[4,5,6]\nc=[7,8,9]\nL1=[a,b,c]\n\ndef initial():\n    global a,b,c,L1\n    a=[1,2,3]\n    b=[4,5,6]\n    c=[7,8,9]\n    L1=[a,b,c]\n\n# L2=L1，L2和L1指向同一个对象，二者是同一对象的两个不同名字\nL2=L1\nL1.append([0,0,0])\nprint(\"L2:\",L2)\n\n\n# L3=L1.copy()，创建一个新的对象，这个对象是 L1 的拷贝，L3 指向这个新对象\ninitial()\nL3=L1.copy()\nL1.append([0,0,0])\nprint(\"L3:\",L3)\n# a 是对一个对象的引用\na.append(4)\nprint(\"L3:\",L3)\n\n# copy.copy() 与 L1.copy() 效果相同\ninitial()\nL4=copy.copy(L1)\nL1.append([0,0,0])\nprint(\"L4:\",L4)\na.append(4)\nprint(\"L4:\",L4)\n\n# copy.deepcopy(L1) 会递归地为 L1 中所有对象创建新的副本。原始对象和它的深拷贝版本在结构上完全独立，修改任何一个对象的成员都不会影响到另一个。\ninitial()\nL5=copy.deepcopy(L1)\nL5.append([0,0,0])\nprint(\"L5:\",L5)\na.append(4)\nprint(\"L5:\",L5)\n```\n\nout:\n\n```\nL2: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]]\nL3: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nL3: [[1, 2, 3, 4], [4, 5, 6], [7, 8, 9]]\nL4: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nL4: [[1, 2, 3, 4], [4, 5, 6], [7, 8, 9]]\nL5: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]]\nL5: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]]\n```\n\n","tags":["常用库"],"categories":["python"]},{"title":"json","url":"/2024/06/03/json/","content":"## json介绍\n\njson是一种轻量级的数据交互格式。主要功能：在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。本质上是一个有特殊格式的字符串。\n\npython的列表与字典和json数据格式非常像。\n\njson数据示例：\n\n```json\n{\"name\":\"Kangkang\",\"age\":18}\n```\n\n```json\n[{\"name\":\"Kangkang\",\"age\":18},{\"name\":\"Maria\",\"age\":16},{\"name\":\"Jane\",\"age\":15}]\n```\n\n## json库的方法\n\n+ `dumps()` 把py数据转为json数据\n\n  ```python\n  l=[{\"name\":\"Kangkang\",\"age\":18},{\"name\":\"Maria\",\"age\":16},{\"name\":\"Jane\",\"age\":15}]\n  json_str=json.dumps(l)\n  print(json_str)\n  print(type(json_str))\t\t\t\t\n  ```\n\n  输出：\n\n  ```python\n  [{\"name\": \"\\u5eb7\\u5eb7\", \"age\": 18}, {\"name\": \"Maria\", \"age\": 16}, {\"name\": \"Jane\", \"age\": 15}]\n  <class 'str'>\n  ```\n\n  为了使中文正常显示需要加参数 `ensure_ascii`\n\n  ```python\n  json_str=json.dumps(l,ensure_ascii=False)\n  ```\n\n+ `loads()` 把json数据转为py数据\n\n  ```python\n  json_str='[{\"name\":\"Kangkang\",\"age\":18},{\"name\":\"Maria\",\"age\":16},{\"name\":\"Jane\",\"age\":15}]'\n  l=json.loads(json_str)\n  print(l)\n  print(type(l))\n  ```\n\n  输出：\n\n  ```python\n  [{'name': 'Kangkang', 'age': 18}, {'name': 'Maria', 'age': 16}, {'name': 'Jane', 'age': 15}]\n  <class 'list'>\n  ```\n\n  \n\n","tags":["常用库"],"categories":["python"]},{"title":"os","url":"/2024/06/03/os/","content":"\n# 路径的表示\n\n在 MacOS 和 Linux 系统下，路径默认使用的都是正斜杠'/'，在Windows系统下，正反斜杠都可以表示路径分隔符，默认的是反斜杠 '\\\\'。\n\n当前路径的初始值并不是脚本代码所在路径，而是 `VScode` 等 IDE 当前打开的文件夹。\n## os常用基本方法\n\n| 方法                                      | 功能                                                                                          |\n| --------------------------------------- | ------------------------------------------------------------------------------------------- |\n| os.getcwd()                             | 获取Python当前的工作路径                                                                             |\n| os.chdir(folderpath)                    | 将当前工作文件夹改为path                                                                              |\n| os.rename(old_path,new_path)            | 重命名                                                                                         |\n| os.remove(filepath)                     | 删除文件                                                                                        |\n| os.mkdir(folderpath)                    | 创建文件夹（如果folderpath已存在会抛出错误）                                                                 |\n| os.rmdir(folderpath)                    | 删除空文件夹（如果folderpath非空会抛出错误）                                                                 |\n| os.listdir(folderpath)                  | 遍历文件夹下所有文件                                                                                  |\n| os.path.join(path1,path2 )              | 拼接两个路径                                                                                      |\n| os.makedirs(folderpath, exist_ok=False) | 用于递归创建目录。这意味着如果你想创建的目录的父目录不存在，`os.makedirs`会自动创建所有必需的父目录。如果`exist_ok=True`，那么要创建的目录存在也不会报错。 |\n|                                         |                                                                                             |\n\n## os.walk()\n\n假如目录结构如下：\n\n```\n--a\n  --b\n\ttest.py\n  --c\n```\n\n```python\nimport os\n\nfor root,dirs,files in os.walk(\"./\"):\n    print(root,dirs,files)\n\n```\n\n输出：\n\n```\n./ ['b', 'c'] []\n./b [] ['test.py']\n./c [] []\n```\n\n也就是说，`os.walk` 会遍历当前目录下的所有目录（包括当前目录），每次取出一个目录赋值给 `root`，将这个目录下的目录作为一个列表赋值给 `dirs`，将这个目录下的文件作为一个列表赋值给 `files`。\n\n\n\n\n\n\n## path下的方法\n\n+ os.path.exists(path)：检查文件或文件夹是否存在\n+ os.path.isdir(path)：检查path是否是一个文件夹\n+ os.path.basename(path)：返回一个路径的的最后一层\n+ os.path.join(*path): 将两个或多个路径拼接","tags":["常用库"],"categories":["python"]},{"title":"pipreqs","url":"/2024/06/03/pipreqs/","content":"# pipreqs\n\n用于一键生成 `requirements.txt` 文件。\n\n**安装**\n\n```bash\npip install pipreqs\n```\n\n**使用**\n\n```bash\npipreqs ./ --encoding=utf8 --force\n```\n\n这里的 `--force` 意思是覆盖原有的 `requirements.txt` 文件。\n\n\n\n\n\n\n\n","tags":["常用工具"],"categories":["python"]},{"title":"pathlib","url":"/2024/06/03/pathlib/","content":"## Path\n\n类，表示路径。\n\n`Path(output_folder).mkdir(parents=True, exist_ok=True)`，创建目录 `output_folder`。\n\n- `parents=True`: 如果父目录不存在，也要创建父目录。如果设置为`True`，它将递归地创建所有必要的父目录，以确保目标路径存在。这对于创建多层嵌套的目录非常有用。\n- `exist_ok=True`: 如果设置为`True`，即使目录已经存在，也不会引发异常。这是为了防止在目录已经存在的情况下引发错误。\n- ","tags":["常用库"],"categories":["python"]},{"title":"pdb","url":"/2024/06/03/pdb/","content":"\n## 导入\n\n```\nimport pdb\n```\n\n## 设置断点\n\n```python\npdb.set_trace()\n```\n\n## 命令\n\n`c`：执行到下一个断点\n\n`p <val>`：打印变量 `<val>` 的值\n\n`n`：运行一行\n\n`l`：列出当前运行处的代码","tags":["常用工具"],"categories":["python"]},{"title":"pymysql","url":"/2024/06/03/pymysql/","content":"## 连接到数据库\n\n```python\ndb=pymysql.connect(\n\t\t# 主机名\n        host='localhost',\n\t\t# 端口\n        port=3306,\n\t\t# 用户名\n        user='root',\n\t\t# 密码\n        password='password',\n\t\t# 数据库\n        database='eng_zn_dictionary',\n\t\t# 自动 commit\n        autocommit=True,\n    )\ncursor = db.cursor()\n```\n\n## 执行\n\n```python\ncursor.execute(\"SELECT * FROM your_table\")\n```\n\n如果不置 `autocommit=True`，每执行一句 `SQL` 语句后要执行一句 `db.commit()`\n\n## 获取结果\n\n```python\nresults = cursor.fetchall()\n```\n\n## 回滚\n\n```python\ntry:\n    # 执行 SQL 语句\n    cursor.execute(sql)\n    # 提交到数据库执行\n    conn.commit()\nexcept:\n    # 发生错误时回滚\n    conn.rollback()\n\n```\n\n## 关闭\n\n```python\ncursor.close()\n```\n","tags":["常用库"],"categories":["python"]},{"title":"pynput","url":"/2024/06/03/pynput/","content":"pynput这个库，允许你控制、监听输入设备。例如监听鼠标、键盘的各种操作。","tags":["常用库"],"categories":["python"]},{"title":"random","url":"/2024/06/03/random/","content":"1.  `seed()` 设置随机数种子，默认以系统时间作为种子。\n2.  `random()` 生成一个 `[0.0,1.0]` 之间的随机小数。\n3.  `randint(a,b)` 生成一个 `[a,b]` 之间的随机整数（注意是左闭右闭）。\n4.  `uniform(a,b)` 生成一个 `[a,b]` 之间的随机浮点数。\n5.  `choice(seq)` 从 `seq` 中随机取出一个元素。\n6.  `shuffle(seq)` 将 `seq` 打乱，就地打乱，无返回值。\n7.  `sample(data,n)`：从一个给定的序列data（如列表、元组等）中随机抽取n个不重复的元素，并以列表形式返回这些元素。","tags":["常用库"],"categories":["python"]},{"title":"setuptools","url":"/2024/06/03/setuptools/","content":"## setuptools\n\n用于打包和分发Python项目\n\n## setup\n\n用于安装包\n\n```python\nfrom setuptools import setup\n\nsetup(\n    name=\"ddpm\",\n    py_modules=[\"ddpm\"],\n    install_requires=[\"torch\", \"torchvision\", \"einops\", \"wandb\", \"joblib\"],\n)\n```\n\n用法：在包含该脚本的目录下运行 `pip install .`","tags":["常用库"],"categories":["python"]},{"title":"socket","url":"/2024/06/03/socket/","content":"+ 假设已经 `import socket` 。\n+ addr 的格式是 `(ip,port)` 或 `(hostname,port)` ，它是一个元组。\n# 创建socket\n```python\nsk=socket(family,type)\n```\nfamily 取值：AF_INET(IPv4)、DF_INET6(IPv6)\ntype 取值：SOCK_STREAM（TCP协议）、SOCK_DGRAM（UDP协议）\n\n# connect\n```python\nsk.connect(addr)\n```\n连接到一个远程的 socket。\n\n# bind\n```python\nsk.bind(addr)\n```\n将 sk 绑定到一个地址。\n\n# listen(backlog)\n监听，使得服务器能够接收客户端连接。 backlog 是连接的最大数量。\n\n# accept\n```python\ncon_sk,addr=sk.accept()\n```\n等待接受一个连接。前提是 socket 必须已经绑定了一个地址。等待是阻塞式的。连接建立成功后返回元组 `(connectionsocket,addr)`，分别是新的 socket 对象和远端主机的地址。\n# send\n```python\nsk.send(bytes)\n```\n该 socket 发送数据 bytes。发送前 sk 必须已经 connect 到目的地址。\n# sendto\n```python\nsk.sendto(bytes,addr)\n```\n该 socket 向 addr 处发送数据 bytes。\n# recv\n```python\nmsg=sk.recv(bufsize)\n```\n该 socket 等待接收数据，大小最多为 bufsize 字节。等待是阻塞式的。\n\n# recvfrom\n```python\nmsg,addr=sk.recvfrom(bufsize)\n```\n与 recv 的区别在于不仅返回数据，还返回发送方地址。即返回一个 (data,addr) 的元组。\n\n# close\n```python\nsk.close()\n```\n关闭 sk。\n","tags":["python-常用库"]},{"title":"re","url":"/2024/06/03/re/","content":"## re模块三种主要的正则表达式匹配方法\n### match()\n`match(pattern, string)` 会在 string 中匹配正则表达式 pattern ，这个方法从头开始匹配，且只匹配第一个命中项。没有匹配到时返回 `None` 。\n\n```python\nimport re\ns1=\"000python111pythonpython222\"\ns2=\"python111pythonpython222\"\nresult1=re.match('python',s1)\nresult2=re.match('python',s2)\nprint(result1)\nprint(result2)\n```\n\n输出：\n\n```python\nNone\n<re.Match object; span=(0, 6), match='python'>\n```\n\n通过 `result.group()` 和 `result.span()` 可以分别查看匹配到的字符串内容及其起止位置（这个起止位置是左闭右开的）\n\n### `group` 方法的使用\n\n- `match_object.group(n)`：这里，`n` 是一个整数，代表正则表达式中第 `n` 个括号（括号用于在正则表达式中创建分组）的匹配结果。\n- 如果正则表达式中有多个括号（分组），它们将按照在表达式中出现的顺序从左到右编号，从 1 开始。\n- `group(0)` 或 `group()` 返回整个匹配的字符串。\n\n### search\n\n`search(pattern, string)` 与`match(pattern, string)` 类似，但是是全局匹配而非从头匹配。它也只匹配第一个命中项。\n\n### findall\n\n`findall(pattern,string)` 会进行全局匹配且匹配所有命中项，返回的是一个匹配到的字符串的列表，没有匹配到内容的时候返回空列表。\n\n## 替换匹配的文本\n\n```python\nimport re\n\ndef square(match):\n    num = int(match.group())\n    return str(num * num)\n\ntext = \"这是一个示例文本，其中包含1234一些数字5678。\"\n\n# 使用正则表达式匹配文本中的所有数字\npattern = r'\\d+'\nresult = re.sub(pattern, square, text)\n\nprint(result)\n\n```\n\n## 字符串匹配规则\n\n| 字符 | 功能                             |      |\n| :--- | :------------------------------- | :--: |\n| .    | 匹配任意一个字符（除了\\n）       |      |\n| []   | 匹配[ ]中列举的字符              |      |\n| \\\\.  | 匹配 .                           |      |\n| \\d   | 匹配数字                         |      |\n| \\D   | 匹配非数字                       |      |\n| \\s   | 匹配空白，即空格或Tab            |      |\n| \\S   | 匹配非空白                       |      |\n| \\w   | 匹配单词字符，即a-z、A-Z、0-9、_ |      |\n| \\W   | 匹配非单词字符                   |      |\n\n+ 字符串前面加 `r` 标记，表示其转义字符无效。正则表达式也是一个字符串，其中的 `\\` 应该被按照正则表达式的规则解析，而非转义字符。所以正则表达式前一般有 `r` 标记。\n+ `[]` 使用例子：匹配所有英文字符：`[A-Za-z]` 。匹配2或4或6： `[246]` \n+ 正则表达式不要写额外的空格\n\n## 数量匹配\n\n| 字符  | 功能                                       |\n| ----- | ------------------------------------------ |\n| *     | 匹配前一个规则的字符出现0至无数次          |\n| +     | 匹配前一个规则的字符出现1至无数次          |\n| ？    | 匹配前一个规则的字符出现0或1次             |\n| {m}   | 匹配前一个规则的字符出现m次                |\n| {m,}  | 匹配前一个规则的字符出现m至无数次          |\n| {m,n} | 匹配前一个规则的字符出现m至n次（左闭右闭） |\n\n## 边界匹配\n\n| 字符 | 功能                 |\n| :--- | -------------------- |\n| ^    | 匹配字符串的开头     |\n| $    | 匹配字符串的结尾     |\n| \\b   | 匹配一个单词的边界   |\n| \\B   | 匹配一个非单词的边界 |\n\n## 其他运算符\n\n| 字符 | 功能       |\n| ---- | ---------- |\n| \\|   | 并         |\n| ()   | 确定优先级 |\n\n+ 如果有 `()` 进行分组， `findall()` 会将每个括号内的表达式匹配到的内容都找到并包装成元组。","tags":["常用库"],"categories":["python"]},{"title":"sys","url":"/2024/06/03/sys/","content":"## 读入命令行参数\n\n```python\nimport sys\n\n# 获取命令行参数\nscript_name = sys.argv[0]\narguments = sys.argv[1:]\n\n# 打印脚本名称和参数\nprint(f\"Script Name: {script_name}\")\nprint(f\"Arguments: {arguments}\")\n```","tags":["常用库"],"categories":["python"]},{"title":"time","url":"/2024/06/03/time/","content":"1. `time()` \n\n   获取当前时间戳（浮点数），单位是秒。\n\n   计算机的时间戳通常是从一个特定的起始点开始计时，这个起始点被称为\"Unix纪元\"或\"UNIX Epoch\"。\n\n   Unix纪元的起始点是：\n\n   **时间：** 1970年1月1日，协调世界时（Coordinated Universal Time，UTC）的午夜（00:00:00 UTC）。\n\n2. `time_ns()`\n\n   获取当前时间戳（浮点数），单位是纳秒。\n\n3. `ctime()`\n\n   获取当前时间并以易读的方式表示（字符串）。\n\n   ```python\n   print(ctime())\t\t\t# Sat Aug 19 17:21:13 2023\n   ```\n\n   `ctime(secs)` 会把时间戳secs转为易读的字符串。\n\n4. `gmtime()`\n\n   获取当前时间并以计算机易处理的格外返回（struct_time）。\n\n   ```python\n   print(gmtime())\t\t\t\n   # time.struct_time(tm_year=2023, tm_mon=8, tm_mday=19, tm_hour=9, tm_min=25, tm_sec=13, tm_wday=5, tm_yday=231, tm_isdst=0)\n   ```\n\n   + 这里调用这个语句的时候是17：25 ，tm_hour不是17而是9因为返回的是UTC，我所在的地方是东八区，要加8。\n\n   + `tm_wday=5` 是说此时是一周的第6天，也就是星期六（从0开始计）\n\n     `tm_yday=231` 是说此时是一年的第231天，这个是从1开始计。\n\n     `tm_isdst=0` 说明这个时间不是夏令时。如果 `tm_isdst` 的值为 `-1`，则表示不可用或未知的夏令时信息。这种情况可能发生在操作系统或编程库无法确定夏令时状态的情况下。\n\n   + `gtime(secs)` 会把时间戳secs转为 time_struct 格式。\n\n5. `localtime()`\n\n   基本同上，除了返回的是本地时间。\n\n6. `strptime(string,format)`\n\n   将string按format的规则解析，返回一个 struct_time\n\n   ```python\n   timeStr= '2023-8-19 17:37:44'\n   print(strptime(timeStr, \"%Y-%m-%d %H:%M:%S\"))\n   # time.struct_time(tm_year=2023, tm_mon=8, tm_mday=19, tm_hour=17, tm_min=37, tm_sec=44, tm_wday=5, tm_yday=231, tm_isdst=-1)\n   ```\n\n7. `strftime(format,t)`\n\n   将 struct_time 类型的 t 按format解析，返回一个字符串。\n\n   ```python\n   print(strftime(\"%Y-%m-%d %H:%M:%S\",gmtime()))\n   # 2023-08-19 09:39:42\n   ```\n\n   格式化表示时间的字符串用到的占位符：\n\n   | 占位符 | 意义          | 范围             |\n   | ------ | ------------- | ---------------- |\n   | %Y     | 年份          | 0000~9999        |\n   | %m     | 月份          | 01~12            |\n   | %B     | 月份          | January~December |\n   | %b     | 月份          | Jan~Dec          |\n   | %A     | 星期          | Monday~Sunday    |\n   | %a     | 星期          | Mon~Sun          |\n   | %H     | 小时（24h制） | 00~23            |\n   | %I     | 小时（12h制） | 01~12            |\n   | %p     | 上/下午       | {AM,PM}          |\n   | %M     | 分钟          | 00~59            |\n   | %S     | 秒钟          | 00~59            |\n\n8. `sleep(secs)`\n\n   程序休眠 secs 秒（浮点数）\n\n9. `perf_counter()`\n\n   返回一个CPU级别的精确时间计数值，单位为秒。这个计数值起点不确定，两次调用求差值才有意义。\n\n10. `perf_counter_ns()`\n\n    同上，但单位是纳秒。","tags":["常用库"],"categories":["python"]},{"title":"threading","url":"/2024/06/03/threading/","content":"## demo\n\n创建两个线程，分别执行函数 `eyekeyboard` 和 `terminal`\n\n```python\n# 监视键盘\nkeyboard_thread = threading.Thread(target=eyekeyboard,daemon=True)\nkeyboard_thread.start()\n\n\n# 终端\nterminal_thread = threading.Thread(target=terminal)\nterminal_thread.start()\n```\n\n这里参数 `daemon=True` 意思是将这个线程设置为**守护线程**。守护线程会在主线程结束时自动结束。\n\n## 线程间通信\n\n使用 `queue`\n\n```python\nimport threading\nimport queue\nimport time\n\nQ=queue.Queue()\ndef th1_fun():\n    while True:\n        time.sleep(1)\n        Q.put({\"apple\":1,\"banana\":2})\n\n\ndef th2_fun():\n    while True:\n        time.sleep(1)\n        (apple,banana)=Q.get().values()\n        print(apple,banana)\nth1=threading.Thread(target=th1_fun)\nth1.start()\n\nth2=threading.Thread(target=th2_fun)\nth2.start()\n```\n\n一个线程`put`，另一个线程`get`。","tags":["常用库"],"categories":["python"]},{"title":"Hello World","url":"/2024/06/03/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]